/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc_specification.h"
#include "errno.h"

struct rpc_CommandBuf output;
#define TEMP_BUF_LEN 255
extern FILE *logfp;


rpc_CommandBuf *
executecommand_1_svc(rpc_CommandBuf *argp, struct svc_req *rqstp)
{
	//argp->buffer size is 4096
	char cmdBuf[4110]={0};
  	int counter=0;

#ifdef _PUMA6_ARM_
	/*
	   Special case hack to allow running nfq.sh without waiting for output
	   etc. Don't make this a general case without more in depth review and
	   tested (e.g. there are existing rpcclient2 calls which try to run
	   scripts in the background... they probably don't work but suddenly
	   "fixing" them by checking for " &" at the end of all commands might
	   cause unexpected consequences).
	*/
	if ((strncmp(argp->buffer, "/usr/sbin/nfq.sh ", strlen("/usr/sbin/nfq.sh ")) == 0) &&
	    ((strlen(argp->buffer) > 3) && (strcmp(argp->buffer + strlen(argp->buffer) - 2, " &") == 0)))
	{
		RPC_PRINT("rpcserver - %s, system('%s')\n",__FUNCTION__,argp->buffer);
		system(argp->buffer);
		strcpy(output.buffer, "done");
		return &output;
	}
#endif

	snprintf(cmdBuf,sizeof(cmdBuf),"%s 2>&1",argp->buffer);
	RPC_PRINT("Server received command %s \n",cmdBuf);
	FILE *cmd = popen(cmdBuf, "r");
	if (! cmd)
	{
		RPC_PRINT("command failed %s , error (errno %d) %s \n",cmdBuf, errno, strerror(errno));
		return NULL;
	}
	char line [128] = {0}; /* or other suitable maximum line size */
	memset (output.buffer,0,4096);
        int MAXCOUNTER= (sizeof(output.buffer)/sizeof(line) );
		while ( fgets ( line, sizeof (line), cmd ) != NULL ) 
		{  
		   if (counter >= MAXCOUNTER ) 
                   {
                      if ( (strlen(output.buffer) + strlen(line) ) >= sizeof(output.buffer) )
                              break;
                   }
			/*Here destination output.buffer size is 4096.
			As per safec limitation, it won't copy to the destination buffer , if destination size is more than 4K*/
			strcat(output.buffer,line);
                  	counter++;
		}
		pclose ( cmd );
		return &output;
}


int * exec_1_svc(rpc_CommandBuf *cmd, struct svc_req *req)
{
	//cmd->buffer size is 4096
	char cmdBuf[4100]={0};
	/* CID- 61247 : Pointer to local outside scope */
        static int ret = 1;
	snprintf(cmdBuf,sizeof(cmdBuf),"%s &",cmd->buffer);
	system(cmdBuf);
	return &ret;
}

